import * as _ from 'lodash';
import * as moment from 'moment';
import {BlockServices, EncryptionServices} from "../services";
import {Debug} from "./Debug";

export interface IBlock {
    index: number;
    timestamp: number;
    data: object;
    target: number;
    nonce: number;
    prevHash: string;
    currHash: string;
}

export class Block implements IBlock {
    /*
    1) index: indicates the index of the block ex: 0,1
    2) timestamp: timestamp in epoch, number of seconds since 1 Jan 1970

    3) data: the actual data that needs to be stored on blockchain
    4) prevHash: the hash of the previous block, this is the chain/link between the blocks
    5) nonce: this is a magical number that is to be mined/found, we will explore about it in later posts
    6) target: number of leading zeros for the current hash, again we will explore about it in later posts
    7) currHash: The hash value of the current block, this is generated by combining all the above attributes and passing it to a hashing algorithm
    */

    public index: number;
    public timestamp: number;
    public data: object;
    public target: number;
    public nonce: number;
    public prevHash: string;
    public currHash: string;

    constructor(data?: any) {
        const prevBlock = !_.isNil(data) && !_.isNil(data.prevBlock) ? data.prevBlock : null;
        this.index = !_.isNil(data) && !_.isNil(data.index) ? data.index : this.setIndex(prevBlock);
        this.timestamp = !_.isNil(data) && !_.isNil(data.timestamp) ? data.timestamp : moment.utc().unix();
        this.data = !_.isNil(data) && !_.isNil(data.data) ? data.data : {};
        this.target = !_.isNil(data) && !_.isNil(data.target) ? data.target : this.setTarget();
        this.nonce = !_.isNil(data) && !_.isNil(data.nonce) ? data.nonce : 0;
        this.prevHash = !_.isNil(data) && !_.isNil(data.prevHash) ? data.prevHash : this.setPrevHash(prevBlock);
        this.currHash = !_.isNil(data) && !_.isNil(data.currHash) ? data.currHash : this.encryptCurrHash();
    };

    setIndex(prevBlock: Block): number {
        if (prevBlock) {
            return prevBlock.index + 1;
        } else {
            return 0;
        }
    }

    setTarget(): number {
        return Math.ceil(this.index);
    }

    setPrevHash(prevBlock: Block): string {
        if (prevBlock) {
            return prevBlock.currHash;
        } else {
            return '00000';
        }
    }

    encryptCurrHash(): string {
        const contentToHash = [
                this.index,
                this.timestamp,
                this.data,
                this.prevHash,
                this.nonce,
                this.target
            ],
            hash = EncryptionServices.hash(JSON.stringify(contentToHash));
        return hash;
    };

    static createNonce(): Promise<number> {
        return BlockServices.getAllBlocks()
            .then((blocks: Block[]) => {
                const nonceList = blocks.map(b => b.nonce);
                let nonce;
                do {
                    nonce = Math.round(Math.random() * 100000000000000000000000000000000);
                    Debug.data('nonce try: ' + nonce);
                } while (nonceList.indexOf(nonce) > -1);
                return nonce;
            });
    }

    static isValid(block: Block, previousBlock: Block): boolean {
        return block.prevHash === previousBlock.currHash;
    };

}