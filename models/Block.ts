import * as _ from 'lodash';
import {Moment} from 'moment';
import {EncryptionServices} from "../services/encryptionServices";


let _ = require('lodash'),
    moment = require('moment'),
    encryptionServices = require('../services').encryptionServices,
    blockServices = require('../services').blockServices;



export class Block {

    /*
    1) index: indicates the index of the block ex: 0,1
    2) timestamp: timestamp in epoch, number of seconds since 1 Jan 1970

    3) data: the actual data that needs to be stored on blockchain
    4) prevHash: the hash of the previous block, this is the chain/link between the blocks
    5) nonce: this is a magical number that is to be mined/found, we will explore about it in later posts
    6) target: number of leading zeros for the current hash, again we will explore about it in later posts
    7) currHash: The hash value of the current block, this is generated by combining all the above attributes and passing it to a hashing algorithm
    */

    constructor(data) {
        this.index = !_.isNil(data) && !_.isNil(data.index) ? data.index : 0;
        this.timestamp = !_.isNil(data) && !_.isNil(data.timestamp) ? data.timestamp : moment.utc().unix();
        this.data = !_.isNil(data) && !_.isNil(data.data) ? data.data : {};
        this.prevHash = !_.isNil(data) && !_.isNil(data.prevHash) ? data.prevHash : '0000000000';
        this.target = !_.isNil(data) && !_.isNil(data.target) ? data.target : this.setTarget();
        this.nonce = !_.isNil(data) && !_.isNil(data.nonce) ? data.nonce : 0;
        this.currHash = !_.isNil(data) && !_.isNil(data.currHash) ? data.currHash : this.encryptCurrHash();
    };

    setTarget() {
        return Math.ceil(parseInt(this.index));
    }

    encryptCurrHash() {
        const contentToHash = [
                this.index,
                this.timestamp,
                this.data,
                this.prevHash,
                this.nonce,
                this.target
            ],
            hash = EncryptionServices.hash(JSON.stringify(contentToHash));
        return hash;
    };

    static createNonce() {
        console.log(33223222)
        return blockServices.getAllBlocks()
            .then(res => {
                res = res.map(b => b.nonce);
                let nonce;
                do {
                    nonce = Math.round(Math.random() * 100000000000000000000000000000000);
                    console.log(nonce);
                } while (res.indexOf(nonce) > -1);
                return nonce;
            });
    }

    static isValid(block, previousBlock) {
        return block.previousHash === previousBlock.hash;
    };

};